{
  "network": "testnet4",
  "deployerAddress": "STS1D1ZNN1D0MKS62RCPMF5Z9RG9BREMC6MZ5R72",
  "timestamp": "2025-10-24T12:01:37.142Z",
  "contracts": [
    {
      "contractName": "farmer-registry",
      "status": "prepared",
      "estimatedFee": 50000,
      "codeLength": 4155,
      "contractCode": ";; FarmerRegistry Contract\n;; Manages farmer registration, verification, and profile data\n\n;; Error constants\n(define-constant ERR-NOT-AUTHORIZED (err u100))\n(define-constant ERR-FARMER-EXISTS (err u101))\n(define-constant ERR-FARMER-NOT-FOUND (err u102))\n(define-constant ERR-INVALID-REGION (err u103))\n\n;; Contract owner\n(define-constant CONTRACT-OWNER tx-sender)\n\n;; Data structures\n(define-map farmers\n  { farmer-id: principal }\n  {\n    name: (string-ascii 100),\n    region: (string-ascii 50),\n    wallet-address: principal,\n    verified: bool,\n    registration-block: uint,\n    verifier: (optional principal)\n  }\n)\n\n(define-map farmer-stats\n  { farmer-id: principal }\n  {\n    total-batches: uint,\n    total-revenue: uint,\n    reputation-score: uint\n  }\n)\n\n;; Verification authorities (government/NGO addresses)\n(define-map verifiers\n  { verifier: principal }\n  { authorized: bool }\n)\n\n;; Public functions\n\n;; Register a new farmer\n(define-public (register-farmer (name (string-ascii 100)) (region (string-ascii 50)))\n  (let ((farmer-id tx-sender))\n    (asserts! (is-none (map-get? farmers { farmer-id: farmer-id })) ERR-FARMER-EXISTS)\n    (asserts! (> (len name) u0) ERR-INVALID-REGION)\n    (asserts! (> (len region) u0) ERR-INVALID-REGION)\n    \n    (map-set farmers\n      { farmer-id: farmer-id }\n      {\n        name: name,\n        region: region,\n        wallet-address: farmer-id,\n        verified: false,\n        registration-block: stacks-block-height,\n        verifier: none\n      }\n    )\n    \n    (map-set farmer-stats\n      { farmer-id: farmer-id }\n      {\n        total-batches: u0,\n        total-revenue: u0,\n        reputation-score: u100\n      }\n    )\n    \n    (print { event: \"farmer-registered\", farmer-id: farmer-id, name: name, region: region })\n    (ok farmer-id)\n  )\n)\n\n;; Verify a farmer (only authorized verifiers)\n(define-public (verify-farmer (farmer-id principal))\n  (let ((verifier tx-sender))\n    (asserts! (default-to false (get authorized (map-get? verifiers { verifier: verifier }))) ERR-NOT-AUTHORIZED)\n    (asserts! (is-some (map-get? farmers { farmer-id: farmer-id })) ERR-FARMER-NOT-FOUND)\n    \n    (map-set farmers\n      { farmer-id: farmer-id }\n      (merge (unwrap-panic (map-get? farmers { farmer-id: farmer-id }))\n        { verified: true, verifier: (some verifier) }\n      )\n    )\n    \n    (print { event: \"farmer-verified\", farmer-id: farmer-id, verifier: verifier })\n    (ok true)\n  )\n)\n\n;; Add authorized verifier (only contract owner)\n(define-public (add-verifier (verifier principal))\n  (begin\n    (asserts! (is-eq tx-sender CONTRACT-OWNER) ERR-NOT-AUTHORIZED)\n    (map-set verifiers { verifier: verifier } { authorized: true })\n    (print { event: \"verifier-added\", verifier: verifier })\n    (ok true)\n  )\n)\n\n;; Update farmer stats (called by other contracts)\n(define-public (update-farmer-stats (farmer-id principal) (batches-increment uint) (revenue-increment uint))\n  (let ((current-stats (default-to { total-batches: u0, total-revenue: u0, reputation-score: u100 }\n                                   (map-get? farmer-stats { farmer-id: farmer-id }))))\n    (map-set farmer-stats\n      { farmer-id: farmer-id }\n      {\n        total-batches: (+ (get total-batches current-stats) batches-increment),\n        total-revenue: (+ (get total-revenue current-stats) revenue-increment),\n        reputation-score: (get reputation-score current-stats)\n      }\n    )\n    (ok true)\n  )\n)\n\n;; Read-only functions\n\n;; Get farmer details\n(define-read-only (get-farmer (farmer-id principal))\n  (map-get? farmers { farmer-id: farmer-id })\n)\n\n;; Get farmer stats\n(define-read-only (get-farmer-stats (farmer-id principal))\n  (map-get? farmer-stats { farmer-id: farmer-id })\n)\n\n;; Check if farmer is verified\n(define-read-only (is-farmer-verified (farmer-id principal))\n  (default-to false (get verified (map-get? farmers { farmer-id: farmer-id })))\n)\n\n;; Check if address is authorized verifier\n(define-read-only (is-authorized-verifier (verifier principal))\n  (default-to false (get authorized (map-get? verifiers { verifier: verifier })))\n)\n\n;; Get contract owner\n(define-read-only (get-contract-owner)\n  CONTRACT-OWNER\n)"
    },
    {
      "contractName": "product-tracking",
      "status": "prepared",
      "estimatedFee": 50000,
      "codeLength": 6955,
      "contractCode": ";; ProductTracking Contract\n;; Tracks product batches through the supply chain with immutable history\n\n;; Error constants\n(define-constant ERR-NOT-AUTHORIZED (err u200))\n(define-constant ERR-BATCH-EXISTS (err u201))\n(define-constant ERR-BATCH-NOT-FOUND (err u202))\n(define-constant ERR-INVALID-STATUS (err u203))\n(define-constant ERR-FARMER-NOT-VERIFIED (err u204))\n\n;; Status constants\n(define-constant STATUS-PRODUCED u1)\n(define-constant STATUS-TRANSPORTED u2)\n(define-constant STATUS-STORED u3)\n(define-constant STATUS-SOLD u4)\n\n;; Contract references will be set during deployment\n\n;; Data structures\n(define-map product-batches\n  { batch-id: (string-ascii 50) }\n  {\n    farmer-id: principal,\n    product-type: (string-ascii 50),\n    quantity: uint,\n    unit: (string-ascii 20),\n    created-at: uint,\n    current-status: uint,\n    current-holder: principal,\n    price-per-unit: uint,\n    quality-grade: (string-ascii 10),\n    harvest-date: uint,\n    expiry-date: uint\n  }\n)\n\n(define-map batch-history\n  { batch-id: (string-ascii 50), event-id: uint }\n  {\n    status: uint,\n    timestamp: uint,\n    actor: principal,\n    location: (string-ascii 100),\n    notes: (string-ascii 200),\n    temperature: (optional int),\n    humidity: (optional uint)\n  }\n)\n\n(define-map batch-event-count\n  { batch-id: (string-ascii 50) }\n  { count: uint }\n)\n\n;; Public functions\n\n;; Record a new product batch (only verified farmers)\n(define-public (record-batch \n  (batch-id (string-ascii 50))\n  (product-type (string-ascii 50))\n  (quantity uint)\n  (unit (string-ascii 20))\n  (price-per-unit uint)\n  (quality-grade (string-ascii 10))\n  (harvest-date uint)\n  (expiry-date uint)\n  (location (string-ascii 100)))\n  \n  (let ((farmer-id tx-sender))\n    ;; Verify farmer exists (simplified - in production would call farmer-registry)\n    ;; (asserts! (contract-call? .farmer-registry is-farmer-verified farmer-id) ERR-FARMER-NOT-VERIFIED)\n    (asserts! (is-none (map-get? product-batches { batch-id: batch-id })) ERR-BATCH-EXISTS)\n    (asserts! (> quantity u0) ERR-INVALID-STATUS)\n    \n    ;; Create batch record\n    (map-set product-batches\n      { batch-id: batch-id }\n      {\n        farmer-id: farmer-id,\n        product-type: product-type,\n        quantity: quantity,\n        unit: unit,\n        created-at: stacks-block-height,\n        current-status: STATUS-PRODUCED,\n        current-holder: farmer-id,\n        price-per-unit: price-per-unit,\n        quality-grade: quality-grade,\n        harvest-date: harvest-date,\n        expiry-date: expiry-date\n      }\n    )\n    \n    ;; Initialize event count\n    (map-set batch-event-count { batch-id: batch-id } { count: u0 })\n    \n    ;; Record initial event\n    (unwrap-panic (add-batch-event batch-id STATUS-PRODUCED farmer-id location \"Batch produced and recorded\" none none))\n    \n    ;; Update farmer stats would be called here in production\n    ;; (try! (contract-call? .farmer-registry update-farmer-stats farmer-id u1 u0))\n    \n    (print { \n      event: \"batch-recorded\", \n      batch-id: batch-id, \n      farmer-id: farmer-id, \n      product-type: product-type,\n      quantity: quantity \n    })\n    (ok batch-id)\n  )\n)\n\n;; Update batch status (transportation, storage, sale)\n(define-public (update-status \n  (batch-id (string-ascii 50))\n  (new-status uint)\n  (location (string-ascii 100))\n  (notes (string-ascii 200))\n  (temperature (optional int))\n  (humidity (optional uint)))\n  \n  (let ((batch (unwrap! (map-get? product-batches { batch-id: batch-id }) ERR-BATCH-NOT-FOUND))\n        (current-status (get current-status batch)))\n    \n    ;; Validate status progression\n    (asserts! (and (>= new-status STATUS-PRODUCED) (<= new-status STATUS-SOLD)) ERR-INVALID-STATUS)\n    (asserts! (> new-status current-status) ERR-INVALID-STATUS)\n    \n    ;; Update batch status\n    (map-set product-batches\n      { batch-id: batch-id }\n      (merge batch { current-status: new-status, current-holder: tx-sender })\n    )\n    \n    ;; Add event to history\n    (unwrap-panic (add-batch-event batch-id new-status tx-sender location notes temperature humidity))\n    \n    (print { \n      event: \"status-updated\", \n      batch-id: batch-id, \n      new-status: new-status, \n      actor: tx-sender \n    })\n    (ok true)\n  )\n)\n\n;; Transfer batch ownership\n(define-public (transfer-batch (batch-id (string-ascii 50)) (new-holder principal))\n  (let ((batch (unwrap! (map-get? product-batches { batch-id: batch-id }) ERR-BATCH-NOT-FOUND)))\n    (asserts! (is-eq tx-sender (get current-holder batch)) ERR-NOT-AUTHORIZED)\n    \n    (map-set product-batches\n      { batch-id: batch-id }\n      (merge batch { current-holder: new-holder })\n    )\n    \n    (print { event: \"batch-transferred\", batch-id: batch-id, from: tx-sender, to: new-holder })\n    (ok true)\n  )\n)\n\n;; Private functions\n\n;; Add event to batch history\n(define-private (add-batch-event \n  (batch-id (string-ascii 50))\n  (status uint)\n  (actor principal)\n  (location (string-ascii 100))\n  (notes (string-ascii 200))\n  (temperature (optional int))\n  (humidity (optional uint)))\n  \n  (let ((current-count (default-to u0 (get count (map-get? batch-event-count { batch-id: batch-id }))))\n        (event-id (+ current-count u1)))\n    \n    (map-set batch-history\n      { batch-id: batch-id, event-id: event-id }\n      {\n        status: status,\n        timestamp: stacks-block-height,\n        actor: actor,\n        location: location,\n        notes: notes,\n        temperature: temperature,\n        humidity: humidity\n      }\n    )\n    \n    (map-set batch-event-count { batch-id: batch-id } { count: event-id })\n    (ok event-id)\n  )\n)\n\n;; Read-only functions\n\n;; Get batch details\n(define-read-only (get-batch (batch-id (string-ascii 50)))\n  (map-get? product-batches { batch-id: batch-id })\n)\n\n;; Get batch history event\n(define-read-only (get-batch-event (batch-id (string-ascii 50)) (event-id uint))\n  (map-get? batch-history { batch-id: batch-id, event-id: event-id })\n)\n\n;; Get batch event count\n(define-read-only (get-batch-event-count (batch-id (string-ascii 50)))\n  (default-to u0 (get count (map-get? batch-event-count { batch-id: batch-id })))\n)\n\n;; Get full batch history\n(define-read-only (get-batch-history (batch-id (string-ascii 50)))\n  (let ((event-count (get-batch-event-count batch-id)))\n    (map get-batch-event-by-id (list u1 u2 u3 u4 u5 u6 u7 u8 u9 u10))\n  )\n)\n\n;; Helper function for batch history\n(define-read-only (get-batch-event-by-id (event-id uint))\n  (get-batch-event \"default\" event-id)\n)\n\n;; Check if batch exists\n(define-read-only (batch-exists (batch-id (string-ascii 50)))\n  (is-some (map-get? product-batches { batch-id: batch-id }))\n)\n\n;; Get status name\n(define-read-only (get-status-name (status uint))\n  (if (is-eq status STATUS-PRODUCED) \"Produced\"\n    (if (is-eq status STATUS-TRANSPORTED) \"In Transit\"\n      (if (is-eq status STATUS-STORED) \"In Storage\"\n        (if (is-eq status STATUS-SOLD) \"Sold\"\n          \"Unknown\"\n        )\n      )\n    )\n  )\n)"
    },
    {
      "contractName": "payment-escrow",
      "status": "prepared",
      "estimatedFee": 50000,
      "codeLength": 8264,
      "contractCode": ";; PaymentEscrow Contract\n;; Manages STX escrow payments between buyers and farmers\n\n;; Error constants\n(define-constant ERR-NOT-AUTHORIZED (err u300))\n(define-constant ERR-ESCROW-EXISTS (err u301))\n(define-constant ERR-ESCROW-NOT-FOUND (err u302))\n(define-constant ERR-INSUFFICIENT-FUNDS (err u303))\n(define-constant ERR-ESCROW-ALREADY-COMPLETED (err u304))\n(define-constant ERR-BATCH-NOT-FOUND (err u305))\n(define-constant ERR-INVALID-AMOUNT (err u306))\n\n;; Escrow status constants\n(define-constant ESCROW-PENDING u1)\n(define-constant ESCROW-CONFIRMED u2)\n(define-constant ESCROW-RELEASED u3)\n(define-constant ESCROW-REFUNDED u4)\n\n;; Contract references will be set during deployment\n;; For local testing, these will be the deployed contract addresses\n\n;; Data structures\n(define-map escrows\n  { escrow-id: (string-ascii 50) }\n  {\n    batch-id: (string-ascii 50),\n    buyer: principal,\n    farmer: principal,\n    amount: uint,\n    status: uint,\n    created-at: uint,\n    delivery-deadline: uint,\n    confirmation-required: bool,\n    buyer-confirmed: bool,\n    farmer-confirmed: bool\n  }\n)\n\n(define-map escrow-funds\n  { escrow-id: (string-ascii 50) }\n  { locked-amount: uint }\n)\n\n;; Public functions\n\n;; Create escrow for a product batch\n(define-public (create-escrow \n  (escrow-id (string-ascii 50))\n  (batch-id (string-ascii 50))\n  (farmer principal)\n  (amount uint)\n  (delivery-deadline uint))\n  \n  (let ((buyer tx-sender))\n        ;; For now, we'll validate batch exists by checking if batch-id is not empty\n        ;; In production, this would call the product-tracking contract\n    \n    ;; Validate inputs\n    (asserts! (is-none (map-get? escrows { escrow-id: escrow-id })) ERR-ESCROW-EXISTS)\n    (asserts! (> amount u0) ERR-INVALID-AMOUNT)\n    ;; Validate batch-id is not empty (simplified validation)\n    (asserts! (> (len batch-id) u0) ERR-BATCH-NOT-FOUND)\n    (asserts! (> delivery-deadline stacks-block-height) ERR-INVALID-AMOUNT)\n    \n    ;; Check buyer has sufficient funds\n    (asserts! (>= (stx-get-balance buyer) amount) ERR-INSUFFICIENT-FUNDS)\n    \n    ;; Transfer STX to contract for escrow\n    (try! (stx-transfer? amount buyer (as-contract tx-sender)))\n    \n    ;; Create escrow record\n    (map-set escrows\n      { escrow-id: escrow-id }\n      {\n        batch-id: batch-id,\n        buyer: buyer,\n        farmer: farmer,\n        amount: amount,\n        status: ESCROW-PENDING,\n        created-at: stacks-block-height,\n        delivery-deadline: delivery-deadline,\n        confirmation-required: true,\n        buyer-confirmed: false,\n        farmer-confirmed: false\n      }\n    )\n    \n    ;; Lock funds\n    (map-set escrow-funds { escrow-id: escrow-id } { locked-amount: amount })\n    \n    (print { \n      event: \"escrow-created\", \n      escrow-id: escrow-id, \n      batch-id: batch-id,\n      buyer: buyer,\n      farmer: farmer,\n      amount: amount \n    })\n    (ok escrow-id)\n  )\n)\n\n;; Buyer confirms delivery\n(define-public (confirm-delivery (escrow-id (string-ascii 50)))\n  (let ((escrow (unwrap! (map-get? escrows { escrow-id: escrow-id }) ERR-ESCROW-NOT-FOUND)))\n    (asserts! (is-eq tx-sender (get buyer escrow)) ERR-NOT-AUTHORIZED)\n    (asserts! (is-eq (get status escrow) ESCROW-PENDING) ERR-ESCROW-ALREADY-COMPLETED)\n    \n    ;; Update buyer confirmation\n    (map-set escrows\n      { escrow-id: escrow-id }\n      (merge escrow { buyer-confirmed: true })\n    )\n    \n    ;; Check if both parties confirmed or only buyer confirmation needed\n    (let ((updated-escrow (unwrap-panic (map-get? escrows { escrow-id: escrow-id }))))\n      (if (or (not (get confirmation-required updated-escrow)) \n              (and (get buyer-confirmed updated-escrow) (get farmer-confirmed updated-escrow)))\n        (release-payment-internal escrow-id)\n        (ok true)\n      )\n    )\n  )\n)\n\n;; Farmer confirms delivery completion\n(define-public (farmer-confirm-delivery (escrow-id (string-ascii 50)))\n  (let ((escrow (unwrap! (map-get? escrows { escrow-id: escrow-id }) ERR-ESCROW-NOT-FOUND)))\n    (asserts! (is-eq tx-sender (get farmer escrow)) ERR-NOT-AUTHORIZED)\n    (asserts! (is-eq (get status escrow) ESCROW-PENDING) ERR-ESCROW-ALREADY-COMPLETED)\n    \n    ;; Update farmer confirmation\n    (map-set escrows\n      { escrow-id: escrow-id }\n      (merge escrow { farmer-confirmed: true })\n    )\n    \n    ;; Check if both parties confirmed\n    (let ((updated-escrow (unwrap-panic (map-get? escrows { escrow-id: escrow-id }))))\n      (if (and (get buyer-confirmed updated-escrow) (get farmer-confirmed updated-escrow))\n        (release-payment-internal escrow-id)\n        (ok true)\n      )\n    )\n  )\n)\n\n;; Release payment to farmer (automatic after confirmations)\n(define-public (release-payment (escrow-id (string-ascii 50)))\n  (let ((escrow (unwrap! (map-get? escrows { escrow-id: escrow-id }) ERR-ESCROW-NOT-FOUND)))\n    ;; Only allow if deadline passed and buyer confirmed, or both parties confirmed\n    (asserts! (or \n      (and (get buyer-confirmed escrow) (> stacks-block-height (get delivery-deadline escrow)))\n      (and (get buyer-confirmed escrow) (get farmer-confirmed escrow))\n    ) ERR-NOT-AUTHORIZED)\n    \n    (release-payment-internal escrow-id)\n  )\n)\n\n;; Refund payment to buyer (if delivery failed)\n(define-public (refund-payment (escrow-id (string-ascii 50)))\n  (let ((escrow (unwrap! (map-get? escrows { escrow-id: escrow-id }) ERR-ESCROW-NOT-FOUND)))\n    ;; Only allow refund if deadline passed and buyer didn't confirm\n    (asserts! (and \n      (> stacks-block-height (get delivery-deadline escrow))\n      (not (get buyer-confirmed escrow))\n    ) ERR-NOT-AUTHORIZED)\n    (asserts! (is-eq (get status escrow) ESCROW-PENDING) ERR-ESCROW-ALREADY-COMPLETED)\n    \n    ;; Transfer funds back to buyer\n    (try! (as-contract (stx-transfer? (get amount escrow) tx-sender (get buyer escrow))))\n    \n    ;; Update escrow status\n    (map-set escrows\n      { escrow-id: escrow-id }\n      (merge escrow { status: ESCROW-REFUNDED })\n    )\n    \n    (print { event: \"payment-refunded\", escrow-id: escrow-id, amount: (get amount escrow) })\n    (ok true)\n  )\n)\n\n;; Private functions\n\n;; Internal function to release payment\n(define-private (release-payment-internal (escrow-id (string-ascii 50)))\n  (let ((escrow (unwrap! (map-get? escrows { escrow-id: escrow-id }) ERR-ESCROW-NOT-FOUND)))\n    (asserts! (is-eq (get status escrow) ESCROW-PENDING) ERR-ESCROW-ALREADY-COMPLETED)\n    \n    ;; Transfer funds to farmer\n    (try! (as-contract (stx-transfer? (get amount escrow) tx-sender (get farmer escrow))))\n    \n    ;; Update escrow status\n    (map-set escrows\n      { escrow-id: escrow-id }\n      (merge escrow { status: ESCROW-RELEASED })\n    )\n    \n    ;; Update farmer revenue stats would be called here in production\n    ;; (try! (contract-call? .farmer-registry update-farmer-stats \n    ;;   (get farmer escrow) u0 (get amount escrow)))\n    \n    (print { \n      event: \"payment-released\", \n      escrow-id: escrow-id, \n      farmer: (get farmer escrow),\n      amount: (get amount escrow) \n    })\n    (ok true)\n  )\n)\n\n;; Read-only functions\n\n;; Get escrow details\n(define-read-only (get-escrow (escrow-id (string-ascii 50)))\n  (map-get? escrows { escrow-id: escrow-id })\n)\n\n;; Get locked funds amount\n(define-read-only (get-locked-funds (escrow-id (string-ascii 50)))\n  (map-get? escrow-funds { escrow-id: escrow-id })\n)\n\n;; Check if escrow exists\n(define-read-only (escrow-exists (escrow-id (string-ascii 50)))\n  (is-some (map-get? escrows { escrow-id: escrow-id }))\n)\n\n;; Get escrow status name\n(define-read-only (get-escrow-status-name (status uint))\n  (if (is-eq status ESCROW-PENDING) \"Pending\"\n    (if (is-eq status ESCROW-CONFIRMED) \"Confirmed\"\n      (if (is-eq status ESCROW-RELEASED) \"Released\"\n        (if (is-eq status ESCROW-REFUNDED) \"Refunded\"\n          \"Unknown\"\n        )\n      )\n    )\n  )\n)\n\n;; Check if escrow is ready for release\n(define-read-only (is-ready-for-release (escrow-id (string-ascii 50)))\n  (match (map-get? escrows { escrow-id: escrow-id })\n    escrow (and \n      (is-eq (get status escrow) ESCROW-PENDING)\n      (or \n        (and (get buyer-confirmed escrow) (get farmer-confirmed escrow))\n        (and (get buyer-confirmed escrow) (> stacks-block-height (get delivery-deadline escrow)))\n      )\n    )\n    false\n  )\n)"
    }
  ],
  "totalEstimatedCost": 150000,
  "walletBalance": 5000000000
}